//import dev.nokee.language.cpp.CppHeaderSet
//import dev.nokee.language.c.CHeaderSet
import dev.nokee.language.nativebase.NativeHeaderSet

plugins {
    id 'dev.nokee.native-library'
    id 'dev.nokee.cpp-language'
    id 'dev.nokee.c-language'
}

library(Configure.withDefaultLibraryConfiguration())
library { lib->
    targetLinkages = [linkages.static]

    sources {
        //cpp { from(fileTree(dir: '.', include: '*.cpp')) }
        //c { from(fileTree(dir: '.', include: '*.c')) }
        configureEach(CppSourceSet) { from(fileTree(dir: '.', include: '*.cpp')) }
        //c { from(fileTree(dir: '.', include: '*.c')) }
        //configureEach(CppHeaderSet) { from(isolatedFileTree(dir: projectDir, include: '*.h')) }
        //configureEach(CHeaderSet) { from(isolatedFileTree(dir: projectDir, include: '*.h')) }
        configureEach(NativeHeaderSet) { from(isolatedFileTree(dir: projectDir, include: '*.h')) }
    }

     dependencies {
         implementation 'system.Crypto:libcrypto:current'
         implementation 'system.OpenSSL:libssl:current'
     }

    // TODO-KFH temp change to try to figure out what is bringing in DriverSpec.h
    // TODO(nokeedev): Figuring out where a header comes from should be made easy with Nokee by exposing the data it already acquire during compilation
    //    This is a common question in the native ecosystem.
//    binaries.configureEach {
//        compileTasks.configureEach {
//            compilerArgs.add('/showIncludes')
//        }
//    }
}
