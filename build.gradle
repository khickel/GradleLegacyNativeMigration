import glm.installer.pkgzip.PkgZipInstallerPackage

plugins {
    // https://github.com/dorongold/gradle-task-tree
    id "com.dorongold.task-tree" version "1.5"
    id 'usage'

    id 'glm.installation-manifest-base'
    id 'glm.prebuilt-library-management-base'
    id 'glm.prebuilt-repositories'

    id 'dev.nokeesamples.sonarqube'
}

ext {
    // Code signing info
    codeSignCert = file("MySPC.pfx")
    codeSignPassword = "passwordx"

    isWindows = org.gradle.nativeplatform.platform.internal.DefaultNativePlatform
        .currentOperatingSystem.isWindows()


    // TODO:CLEANUP
    //codeSignCert = "${rootDir}/MySPC.pfx"
    //codeSignPassword = "passwordx"
    //
    // TopProjDir = "${projectDir}/"
    //
    // // Names for our task groups
    // debugGroup = "Legacy Native Migration Example Debug"
    // releaseGroup = "Legacy Native Migration Example Release"
    // releaseString = "1.1.00"
    // versionTextInputFilename = 'VERSION.txt.in'
    // versionTextInputPath = "${rootDir}/${versionTextInputFilename}"

}

// These tasks collect all the various installers into a known location.
def collectDebugInstallers = tasks.register('collectDebugInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/debug')
    doLast {
        println "Debug installers collected to ${destinationDir}."
    }
}

def collectReleaseInstallers = tasks.register('collectReleaseInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/release')
    doLast {
        println "Release installers collected to ${destinationDir}."
    }
}

// TODO:GLM
// TODO:Confluence
// Create an 'all' task that builds everything, debug and release, including building and collecting the installers.
def allTask = tasks.register('all').configure{ allT ->
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('debug')
        if(tsk) { allT.dependsOn(tsk) }

        tsk = sp.tasks.findByName('debugInstaller')
        if(tsk) {
            allT.dependsOn(tsk)
            rootProject.collectDebugInstallers.from(sp.installers.debug.packages*.installerFile)
        }
        
        tsk = sp.tasks.findByName('release')
        if(tsk) { allT.dependsOn(tsk) }

        tsk = sp.tasks.findByName('releaseInstaller')
        if(tsk) {
            allT.dependsOn(tsk)
            rootProject.collectReleaseInstallers.from(sp.installers.release.packages*.installerFile)
        }
    }

    dependsOn(rootProject.collectDebugInstallers)
    dependsOn(rootProject.collectReleaseInstallers)
}
// Create allDebug and allRelease tasks that do everything for that variant.
def allDebugTask = tasks.register('allDebug').configure{
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('debug')
        if(tsk) { it.dependsOn(tsk) }

        tsk = sp.tasks.findByName('debugInstaller')
        if(tsk) {
            it.dependsOn(tsk)
            rootProject.collectDebugInstallers.from(sp.installers.debug.packages*.installerFile)
        }
    }
    dependsOn(rootProject.collectDebugInstallers)
}
def allReleaseTask = tasks.register('allRelease').configure{ 
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('release')
        if(tsk) { it.dependsOn(tsk) }

        tsk = sp.tasks.findByName('releaseInstaller')
        if(tsk) {
            it.dependsOn(tsk)
            rootProject.collectReleaseInstallers.from(sp.installers.release.packages*.installerFile)
        }
    }
    dependsOn(rootProject.collectReleaseInstallers)
}

allprojects {
    apply plugin: 'glm.debug-lifecycle'
    apply plugin: 'glm.release-lifecycle'
    apply plugin: 'default-import'
    apply plugin: 'dev.nokee.visual-studio-ide'
    apply plugin: 'glm.isolated-file-tree'
    apply plugin: 'dev.nokeesamples.sonarqube'

    pluginManager.withPlugin('code-sign') {
        codeSign.certificateDirectory = rootProject.layout.buildDirectory.dir('Certs')
    }

    // Make sure that we know where to find unzipsfx.exe
    project.pluginManager.withPlugin('glm.installer-base') {
        installers.all {
            packages.withType(PkgZipInstallerPackage).all {
                // TODO: This doesn't seem to work properly, I get this error message:
                // * What went wrong:
                // Could not determine the dependencies of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller'.
                // > Failed to query the value of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller' property 'ZSFX'.
                //    > Failed to query the value of property 'ZSFX'.
                //       > Cannot obtain value from provider of environment variable 'UNZIPSFX_LOCATION' at configuration time.
                //         Use a provider returned by 'forUseAtConfigurationTime()' instead.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').map { new File(it) }
                //     .orElse(provider {
                //             throw new GradleException(
                //                 "Please download unzipsfx from <https://sourceforge.net/projects/infozip/files/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip/download>, unzip it, and set the environment variable 'UNZIPSFX_LOCATION'"
                //             ) } )

                // I changed the line to the one below, but then it always throws the exception saying that the env var needs to be set.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').forUseAtConfigurationTime().map { new File(it) }
                def tmpFile
                if(System.getenv('UNZIPSFX_LOCATION')) { 
                    tmpFile = new File(System.getenv('UNZIPSFX_LOCATION'))
                }
                if(tmpFile == null) {
                    throw new GradleException(
                        "Please download unzipsfx with the command 'curl -o unzip.zip <https://managedway.dl.sourceforge.net/project/infozip/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip>', unzip it into a directory, and set the environment variable 'UNZIPSFX_LOCATION' to that location."
                    )
                }
                ZSFX = tmpFile
            }
        }
    }
}

tasks.named('sonarqube') {
    it.properties.putAll([
        'sonar.projectKey': 'test',
        'sonar.sources': '.',

        // Set these env vars for your server information.
        'sonar.host.url': System.getenv('GLM_SONAR_URL'),
        'sonar.login' : System.getenv('GLM_SONAR_TOKEN'),

        'sonar.projectVersion': '1.1.00',
        'sonar.buildString': '1.1.00',
        'sonar.cfamily.threads' : '2',
        'sonar.cfamily.cache.enabled' : 'false',
        //'sonar.cfamily.cache.path' : System.getenv('TEMP') + '\\sqube_cache',
        
        'sonar.projectBaseDir': project.rootDir.absolutePath,
        'sonar.scm.exclusions.disabled': 'true',
        'sonar.exclusions' : '**/*.java,**/*.js',
        'sonar.scm.provider': 'git',

        //'sonar.sourceEncoding': 'UTF-8',
        //'sonar.sourceEncoding': 'US-ASCII',
    ])
}

project(':zsfx_inst') {
    subprojects {
        ext.versionTextInputFilename = 'VERSION.txt.in'
        ext.releaseString = '1.1.00'
    }
}

installationManifests {
    base {
        from('LICENSE')
        from('README.md')
        from('VERSION.txt.in')
    }
}

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Variables and routines for building with Boost
// Location where to find boost, based on environment variable.
ext {
    libBoostIncludePath = 'NOT_SET'
    libBoostLibPathDebug = 'NOT_SET'
    libBoostLibPathRelease = 'NOT_SET'
    libBoostLibName = 'NOT_SET'
}

// If using vcpkg, find Boost.
ext {
    vcpkgInstalledPath = file(System.getenv('GLM_VCPKG_PATH'))
}
libBoostIncludePath = file(vcpkgInstalledPath.getPath() + '/include')
libBoostLibPathDebug = file(vcpkgInstalledPath.getPath() + '/debug/lib')
libBoostLibPathRelease = file(vcpkgInstalledPath.getPath() + '/lib')
// TODO: Convert this to an array, check each item, then use that array in the link flags below.
if(isWindows) {
    libBoostLibName = 'boost_date_time-vc140-mt-gd.lib'
} else {
    libBoostLibName = 'libboost_date_time.a'
}

// Doesn't seem to work with Nokee, from https://stackoverflow.com/questions/10422054/is-there-a-way-to-list-task-dependencies-in-gradle
// gradle.taskGraph.whenReady {taskGraph ->
//     println "Found task graph: " + taskGraph
//     println "Found " + taskGraph.allTasks.size() + " tasks."
//     taskGraph.allTasks.forEach { task ->
//         println()
//         println("----- " + task + " -----")
//         println("depends on tasks: " + task.dependsOn)
//         println("inputs: ")
//         task.inputs.getFiles().getFiles().collect { f -> println(" - " + f)}
//         println("outputs: ")
//         task.outputs.getFiles().getFiles().collect { f -> println(" + " + f)}
//     }
// }

// Check that we can find Boost.
gradle.taskGraph.whenReady { taskGraph ->
    if (!taskGraph.hasTask(":help")) {
        // Check that we can find a Boost header file.
        def h_file = file(libBoostIncludePath.getPath() + '/boost/asio/io_context.hpp')
        if (!h_file.exists()) {
            throw new GradleException("Unable to find Boost header file ${h_file}.");
        }
        // Check that we can find the Boost library file.
        def l_file = file(libBoostLibPathDebug.getPath() + '/' + libBoostLibName)
        if (!l_file.exists()) {
            throw new GradleException("Unable to find Boost library file ${l_file}.");
        }
    }
}

// Given the project add the information needed to compile and link with Boost.
// TODO:
//  For the moment, I left this in, rather than converting it to a prebuild-library.
//  The first reason is that, each consumer of this library will(may?) need to add /DBOOST_NETWORK_ENABLE_HTTPS,
//    and there currently isn't any way to do that from a prebuilt-library.
//    for the future look at this example Daniel from Nokee wrote when he worked at Gradle....
//    https://github.com/gradle/native-samples/tree/master/cpp/publish-macros
//  The other reason is that when using the boost from AMI_BOOST_X86 env var,
//    you only need to add /LIBPATH to the link line, not every library that
//    you want to link with ( I think you do have to for vcpkg, but I need to check that).
//    and there's no way to add a libpath with the prebuilt-library stuff as it is.
def buildWithBoost(Project project) {
    // We need to define BOOST_NETWORK_ENABLE_HTTPS and the include path.
    project.tasks.withType(CppCompile).configureEach { task->
        task.compilerArgs.addAll toolChain.map { tc ->
            if (tc in VisualCpp) {
                return [
                    '/DBOOST_NETWORK_ENABLE_HTTPS',
                    "/I${libBoostIncludePath}"
                ]
            }
        }
    }

    // Add the library path
    project.tasks.withType(LinkExecutable).configureEach{ task->
        task.linkerArgs.addAll toolChain.map { tc ->
            if (tc in VisualCpp) {
                // Figure out which lib path to use based on the task name, there ought to be a better way.
                def lp = libBoostLibPathDebug
                def lf_modifier = '-gd'
                if(task.name.contains('Release')) {
                    lp = libBoostLibPathRelease
                    lf_modifier = ''
                }
                return [
                    "/LIBPATH:${lp}",
                    "boost_filesystem-vc140-mt${lf_modifier}.lib",
                    "boost_serialization-vc140-mt${lf_modifier}.lib",
                    "boost_thread-vc140-mt${lf_modifier}.lib",
                    "boost_log-vc140-mt${lf_modifier}.lib",
                    "boost_log_setup-vc140-mt${lf_modifier}.lib",
                    'Crypt32.lib'
                ]
            }
        }
    }
}

////////////////////////////////////////////////
prebuiltLibraryManagement {

    def openSSLRoot = providers.environmentVariable('GLM_OPENSSL_ROOT').forUseAtConfigurationTime().map { new File(it) }
        .orElse(provider {
                throw new GradleException(
                    "Please set the environment variable 'GLM_OPENSSL_ROOT' to the top of an OpenSSL installation."
                ) } )
        .get()

    def openSSLLibFile = new File(openSSLRoot, 'lib\\libcrypto.lib')
    if(!openSSLLibFile.exists()) {
        throw new GradleException( "The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, ${openSSLLibFile} does not exist." )
    }

    def libPCRERootPath = file(System.getenv('GLM_VCPKG_PATH'))
    def libPCRELibPath = file(libPCRERootPath.getPath() + '/lib')
    def libPCRELibName = 'libpcre.a'
    if(isWindows) {
        libPCRELibName = 'pcre.lib'
    }

    libraries {
        'libcrypto' {
            groupId = 'system.OpenSSL'
            artifactId = 'libcrypto'
            version = '1.1.1h'
            variants {
                x86Shared(SharedLibraryVariant) {
                        includeRoot = new File(openSSLRoot, 'include')
                        importLibraryFile = new File(openSSLRoot, 'lib/libcrypto.lib')
                        runtimeLibraryFile = new File(openSSLRoot, 'libcrypto-1_1.dll')
                        attributes.put(Attribute.of('dev.nokee.linkage', String), 'shared')
                }
            }
        }
        'libssl' {
            groupId = 'system.OpenSSL'
            artifactId = 'libssl'
            version = '1.1.1h'
            variants {
                x86Shared(SharedLibraryVariant) {
                        includeRoot = new File(openSSLRoot, 'include')
                        importLibraryFile = new File(openSSLRoot, 'lib/libssl.lib')
                        runtimeLibraryFile = new File(openSSLRoot, 'libssl-1_1.dll')
                        attributes.put(Attribute.of('dev.nokee.linkage', String), 'shared')
                }
            }
        }
        'libpcre' {
            groupId = 'system.PCRE'
            artifactId = 'libpcre'
            version = 'current'
            variants {
                x86DebugStatic(StaticLibraryVariant) {
                    includeRoot = new File(libPCRERootPath.path)
                    libraryFile = new File(libPCRELibPath, libPCRELibName)
                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'static')
                    attributes.put(Attribute.of('dev.nokee.buildType', String), 'debug')
                }
                x86ReleaseStatic(StaticLibraryVariant) {
                    includeRoot = libPCRERootPath
                    libraryFile = new File(libPCRELibPath, libPCRELibName)
                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'static')
                    attributes.put(Attribute.of('dev.nokee.buildType', String), 'release')
                }
            }
        }
    }
}
