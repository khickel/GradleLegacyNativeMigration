import glm.installer.pkgzip.PkgZipInstallerPackage

plugins {
    // https://github.com/dorongold/gradle-task-tree
    id "com.dorongold.task-tree" version "1.5"
    id 'usage'

    id 'glm.installation-manifest-base'
    id 'glm.prebuilt-library-management-base'
    id 'glm.prebuilt-repositories'
}

ext {
    // Code signing info
    codeSignCert = file("MySPC.pfx")
    codeSignPassword = "passwordx"

    isWindows = org.gradle.nativeplatform.platform.internal.DefaultNativePlatform
        .currentOperatingSystem.isWindows()


    // TODO:CLEANUP
    //codeSignCert = "${rootDir}/MySPC.pfx"
    //codeSignPassword = "passwordx"
    //
    // TopProjDir = "${projectDir}/"
    //
    // // Names for our task groups
    // debugGroup = "Legacy Native Migration Example Debug"
    // releaseGroup = "Legacy Native Migration Example Release"
    // releaseString = "1.1.00"
    // versionTextInputFilename = 'VERSION.txt.in'
    // versionTextInputPath = "${rootDir}/${versionTextInputFilename}"

}

// These tasks collect all the various installers into a known location.
def collectDebugInstallers = tasks.register('collectDebugInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/debug')
    doLast {
        println "Debug installers collected to ${destinationDir}."
    }
}

def collectReleaseInstallers = tasks.register('collectReleaseInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/release')
    doLast {
        println "Release installers collected to ${destinationDir}."
    }
}

// TODO:GLM
// TODO:Confluence
// Create an 'all' task that builds everything, debug and release, including building and collecting the installers.
def allTask = tasks.register('all').configure{ allT ->
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('debug')
        if(tsk) { allT.dependsOn(tsk) }

        tsk = sp.tasks.findByName('debugInstaller')
        if(tsk) {
            allT.dependsOn(tsk)
            rootProject.collectDebugInstallers.from(sp.installers.debug.packages*.installerFile)
        }
        
        tsk = sp.tasks.findByName('release')
        if(tsk) { allT.dependsOn(tsk) }

        tsk = sp.tasks.findByName('releaseInstaller')
        if(tsk) {
            allT.dependsOn(tsk)
            rootProject.collectReleaseInstallers.from(sp.installers.release.packages*.installerFile)
        }
    }

    dependsOn(rootProject.collectDebugInstallers)
    dependsOn(rootProject.collectReleaseInstallers)
}
// Create allDebug and allRelease tasks that do everything for that variant.
def allDebugTask = tasks.register('allDebug').configure{
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('debug')
        if(tsk) { it.dependsOn(tsk) }

        tsk = sp.tasks.findByName('debugInstaller')
        if(tsk) {
            it.dependsOn(tsk)
            rootProject.collectDebugInstallers.from(sp.installers.debug.packages*.installerFile)
        }
    }
    dependsOn(rootProject.collectDebugInstallers)
}
def allReleaseTask = tasks.register('allRelease').configure{ 
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('release')
        if(tsk) { it.dependsOn(tsk) }

        tsk = sp.tasks.findByName('releaseInstaller')
        if(tsk) {
            it.dependsOn(tsk)
            rootProject.collectReleaseInstallers.from(sp.installers.release.packages*.installerFile)
        }
    }
    dependsOn(rootProject.collectReleaseInstallers)
}

////////////////////////////////////////////////////////////////
// Utility function to take a string, add the .exe on the end for windows, empty string for linux, and return the string.
def exe(String fname) {
    if(isWindows) {
        return fname + '.exe'
    } else {
        return fname
    }
}

////////////////////////////////////////////////////////////////
// Utility function to take a string, add the .dll on the end for windows, .so for linux, and return the string.
def dll(String fname) {
    if(isWindows) {
        return fname + '.dll'
    } else {
        return fname + '.so'
    }
}

////////////////////////////////////////////////////////////////
// Utility function to take a string, add the .lib on the end for windows, .a for linux, and return the string.
def lib(String fname) {
    if(isWindows) {
        return fname + '.lib'
    } else {
        return fname + '.a'
    }
}

allprojects {
    apply plugin: 'glm.debug-lifecycle'
    apply plugin: 'glm.release-lifecycle'
    apply plugin: 'default-import'
    apply plugin: 'dev.nokee.visual-studio-ide'
    apply plugin: 'glm.isolated-file-tree'

    pluginManager.withPlugin('code-sign') {
        codeSign.certificateDirectory = rootProject.layout.buildDirectory.dir('Certs')
    }

    // Make sure that we know where to find unzipsfx.exe
    project.pluginManager.withPlugin('glm.installer-base') {
        installers.all {
            packages.withType(PkgZipInstallerPackage).all {
                // TODO: This doesn't seem to work properly, I get this error message:
                // * What went wrong:
                // Could not determine the dependencies of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller'.
                // > Failed to query the value of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller' property 'ZSFX'.
                //    > Failed to query the value of property 'ZSFX'.
                //       > Cannot obtain value from provider of environment variable 'UNZIPSFX_LOCATION' at configuration time.
                //         Use a provider returned by 'forUseAtConfigurationTime()' instead.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').map { new File(it) }
                //     .orElse(provider {
                //             throw new GradleException(
                //                 "Please download unzipsfx from <https://sourceforge.net/projects/infozip/files/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip/download>, unzip it, and set the environment variable 'UNZIPSFX_LOCATION'"
                //             ) } )

                // I changed the line to the one below, but then it always throws the exception saying that the env var needs to be set.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').forUseAtConfigurationTime().map { new File(it) }
                def tmpFile
                if(System.getenv('UNZIPSFX_LOCATION')) { 
                    tmpFile = new File(System.getenv('UNZIPSFX_LOCATION'))
                }
                if(!isWindows) {
                    def binFile = new File('/bin/unzipsfx')
                    if(binFile.exists()) {
                        tmpFile = binFile
                    }
                }
                if(tmpFile == null) {
                    throw new GradleException(
                        "Please download unzipsfx with the command 'curl -o unzip.zip <https://managedway.dl.sourceforge.net/project/infozip/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip>', unzip it into a directory, and set the environment variable 'UNZIPSFX_LOCATION' to that location."
                    )
                }
                ZSFX = tmpFile
                println "Using unzipsfx from ${ZSFX}"
            }
        }
    }
}

if(isWindows) {
    project(':zsfx_inst') {
        subprojects {
            ext.versionTextInputFilename = 'VERSION.txt.in'
            ext.releaseString = '1.1.00'
        }
    }
}

installationManifests {
    base {
        from('LICENSE')
        from('README.md')
        from('VERSION.txt.in')
    }
}

prebuiltLibraryManagement {

    def openSSLRoot = providers.environmentVariable('GLM_OPENSSL_ROOT').forUseAtConfigurationTime().map { new File(it) }
        .orElse(provider {
                throw new GradleException(
                    "Please set the environment variable 'GLM_OPENSSL_ROOT' to the top of an OpenSSL installation."
                ) } )
        .get()

    def openSSLLibFile = new File(openSSLRoot, lib('lib/libssl'))
    if(!openSSLLibFile.exists()) {
        if(!isWindows){
            // Try the linux x64 specific location
            openSSLLibFile = new File(openSSLRoot, lib('lib/x86_64-linux-gnu/libssl'))
        }
        if(!openSSLLibFile.exists()) {
            throw new GradleException( "The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, ${openSSLLibFile} does not exist." )
        } else {
            println "Found libssl here: ${openSSLLibFile}"
        }
    }
    def openSSLLibCryptoFile = new File(openSSLRoot, lib('lib/libcrypto'))
    if(!openSSLLibCryptoFile.exists()) {
        if(!isWindows){
            // Try the linux x64 specific location
            openSSLLibCryptoFile = new File(openSSLRoot, lib('lib/x86_64-linux-gnu/libcrypto'))
        }
        if(!openSSLLibCryptoFile.exists()) {
            throw new GradleException( "The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, ${openSSLLibCryptoFile} does not exist." )
        } else {
            println "Found libcrypto here: ${openSSLLibCryptoFile}"
        }
    }
    libraries {
        'libcrypto' {
            groupId = 'system.OpenSSL'
            artifactId = 'libcrypto'
            version = '1.1.1h'
            variants {
                x86Shared(SharedLibraryVariant) {
                    includeRoot = new File(openSSLRoot, 'include')
                    importLibraryFile = openSSLLibCryptoFile
                    runtimeLibraryFile = new File(openSSLRoot, dll('libcrypto-1_1'))
                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'shared')
                }
            }
        }
        'libssl' {
            groupId = 'system.OpenSSL'
            artifactId = 'libssl'
            version = '1.1.1h'
            variants {
                x86Shared(SharedLibraryVariant) {
                    includeRoot = new File(openSSLRoot, 'include')
                    importLibraryFile = openSSLLibFile
                    runtimeLibraryFile = new File(openSSLRoot, dll('libssl-1_1'))
                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'shared')
                }
            }
        }
    }
}
