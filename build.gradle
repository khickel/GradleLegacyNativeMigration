import glm.installer.pkgzip.PkgZipInstallerPackage

plugins {
    // https://github.com/dorongold/gradle-task-tree
    id "com.dorongold.task-tree" version "1.5"
    id 'usage'

    id 'glm.installation-manifest-base'
    id 'glm.prebuilt-library-management-base'
    id 'glm.prebuilt-repositories'
}

ext {
    // Code signing info
    codeSignCert = file("MySPC.pfx")
    codeSignPassword = "passwordx"
    // TODO:CLEANUP
    //codeSignCert = "${rootDir}/MySPC.pfx"
    //codeSignPassword = "passwordx"
    //
    // TopProjDir = "${projectDir}/"
    //
    // // Names for our task groups
    // debugGroup = "Legacy Native Migration Example Debug"
    // releaseGroup = "Legacy Native Migration Example Release"
    // releaseString = "1.1.00"
    // versionTextInputFilename = 'VERSION.txt.in'
    // versionTextInputPath = "${rootDir}/${versionTextInputFilename}"
}

// These tasks collect all the various installers into a known location.
def collectDebugInstallers = tasks.register('collectDebugInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/debug')
}

def collectReleaseInstallers = tasks.register('collectReleaseInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/release')
}

allprojects {
    apply plugin: 'glm.debug-lifecycle'
    apply plugin: 'glm.release-lifecycle'
    apply plugin: 'default-import'
    apply plugin: 'dev.nokee.visual-studio-ide'
    apply plugin: 'glm.isolated-file-tree'

    pluginManager.withPlugin('code-sign') {
        codeSign.certificateDirectory = rootProject.layout.buildDirectory.dir('Certs')
    }

    // Make sure that we know where to find unzipsfx.exe
    project.pluginManager.withPlugin('glm.installer-base') {
        installers.all {
            packages.withType(PkgZipInstallerPackage).all {
                // TODO: This doesn't seem to work properly, I get this error message:
                // * What went wrong:
                // Could not determine the dependencies of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller'.
                // > Failed to query the value of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller' property 'ZSFX'.
                //    > Failed to query the value of property 'ZSFX'.
                //       > Cannot obtain value from provider of environment variable 'UNZIPSFX_LOCATION' at configuration time.
                //         Use a provider returned by 'forUseAtConfigurationTime()' instead.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').map { new File(it) }
                //     .orElse(provider {
                //             throw new GradleException(
                //                 "Please download unzipsfx from <https://sourceforge.net/projects/infozip/files/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip/download>, unzip it, and set the environment variable 'UNZIPSFX_LOCATION'"
                //             ) } )

                // I changed the line to the one below, but then it always throws the exception saying that the env var needs to be set.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').forUseAtConfigurationTime().map { new File(it) }
                def tmpFile
                if(System.getenv('UNZIPSFX_LOCATION')) { 
                    tmpFile = new File(System.getenv('UNZIPSFX_LOCATION'))
                }
                if(tmpFile == null) {
                    throw new GradleException(
                        "Please download unzipsfx from <https://sourceforge.net/projects/infozip/files/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip/download>, unzip it, and set the environment variable 'UNZIPSFX_LOCATION'"
                    )
                }
                ZSFX = tmpFile
            }
        }
    }
}

project(':zsfx_inst') {
    subprojects {
        ext.versionTextInputFilename = 'VERSION.txt.in'
        ext.releaseString = '1.1.00'
    }
}

installationManifests {
    base {
        from('LICENSE')
        from('README.md')
        from('VERSION.txt.in')
    }
}

prebuiltLibraryManagement {

    def openSSLRoot = providers.environmentVariable('GLM_OPENSSL_ROOT').forUseAtConfigurationTime().map { new File(it) }
        .orElse(provider {
                throw new GradleException(
                    "Please set the environment variable 'GLM_OPENSSL_ROOT' to the top of an OpenSSL installation."
                ) } )
        .get()

    def openSSLLibFile = new File(openSSLRoot, 'lib\\libcrypto.lib')
    if(!openSSLLibFile.exists()) {
        throw new GradleException( "The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, ${openSSLLibFile} does not exist." )
    }
    libraries {
        'libcrypto' {
            groupId = 'system.OpenSSL'
            artifactId = 'libcrypto'
            version = '1.1.1h'
            variants {
                x86Shared(SharedLibraryVariant) {
                        includeRoot = new File(openSSLRoot, 'include')
                        importLibraryFile = new File(openSSLRoot, 'lib/libcrypto.lib')
                        runtimeLibraryFile = new File(openSSLRoot, 'libcrypto-1_1.dll')
                        attributes.put(Attribute.of('dev.nokee.linkage', String), 'shared')
                }
            }
        }
        'libssl' {
            groupId = 'system.OpenSSL'
            artifactId = 'libssl'
            version = '1.1.1h'
            variants {
                x86Shared(SharedLibraryVariant) {
                        includeRoot = new File(openSSLRoot, 'include')
                        importLibraryFile = new File(openSSLRoot, 'lib/libssl.lib')
                        runtimeLibraryFile = new File(openSSLRoot, 'libssl-1_1.dll')
                        attributes.put(Attribute.of('dev.nokee.linkage', String), 'shared')
                }
            }
        }
    }
}
