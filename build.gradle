import glm.installer.pkgzip.PkgZipInstallerPackage

import static PrebuiltLibraryUtils.*

plugins {
    // https://github.com/dorongold/gradle-task-tree
    id "com.dorongold.task-tree" version "1.5"
    id 'usage'

    id 'glm.installation-manifest-base'
    id 'glm.prebuilt-library-management-base'
    id 'glm.prebuilt-repositories'
}

ext {
    // Code signing info
    codeSignCert = file("MySPC.pfx")
    codeSignPassword = "passwordx"

    isWindows = org.gradle.nativeplatform.platform.internal.DefaultNativePlatform
        .currentOperatingSystem.isWindows()


    // TODO:CLEANUP
    //codeSignCert = "${rootDir}/MySPC.pfx"
    //codeSignPassword = "passwordx"
    //
    // TopProjDir = "${projectDir}/"
    //
    // // Names for our task groups
    // debugGroup = "Legacy Native Migration Example Debug"
    // releaseGroup = "Legacy Native Migration Example Release"
    // releaseString = "1.1.00"
    // versionTextInputFilename = 'VERSION.txt.in'
    // versionTextInputPath = "${rootDir}/${versionTextInputFilename}"

}

// These tasks collect all the various installers into a known location.
def collectDebugInstallers = tasks.register('collectDebugInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/debug')
    doLast {
        println "Debug installers collected to ${destinationDir}."
    }
}

def collectReleaseInstallers = tasks.register('collectReleaseInstallers', Sync).configure {
    destinationDir = file(rootProject.projectDir.path + '/installers/release')
    doLast {
        println "Release installers collected to ${destinationDir}."
    }
}

// TODO:GLM
// TODO:Confluence
// Create an 'all' task that builds everything, debug and release, including building and collecting the installers.
def allTask = tasks.register('all').configure{ allT ->
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('debug')
        if(tsk) { allT.dependsOn(tsk) }

        tsk = sp.tasks.findByName('debugInstaller')
        if(tsk) {
            allT.dependsOn(tsk)
            rootProject.collectDebugInstallers.from(sp.installers.debug.packages*.installerFile)
        }
        
        tsk = sp.tasks.findByName('release')
        if(tsk) { allT.dependsOn(tsk) }

        tsk = sp.tasks.findByName('releaseInstaller')
        if(tsk) {
            allT.dependsOn(tsk)
            rootProject.collectReleaseInstallers.from(sp.installers.release.packages*.installerFile)
        }
    }

    dependsOn(rootProject.collectDebugInstallers)
    dependsOn(rootProject.collectReleaseInstallers)
}
// Create allDebug and allRelease tasks that do everything for that variant.
def allDebugTask = tasks.register('allDebug').configure{
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('debug')
        if(tsk) { it.dependsOn(tsk) }

        tsk = sp.tasks.findByName('debugInstaller')
        if(tsk) {
            it.dependsOn(tsk)
            rootProject.collectDebugInstallers.from(sp.installers.debug.packages*.installerFile)
        }
    }
    dependsOn(rootProject.collectDebugInstallers)
}
def allReleaseTask = tasks.register('allRelease').configure{ 
    subprojects.each { sp ->
        def tsk
        tsk = sp.tasks.findByName('release')
        if(tsk) { it.dependsOn(tsk) }

        tsk = sp.tasks.findByName('releaseInstaller')
        if(tsk) {
            it.dependsOn(tsk)
            rootProject.collectReleaseInstallers.from(sp.installers.release.packages*.installerFile)
        }
    }
    dependsOn(rootProject.collectReleaseInstallers)
}

allprojects {
    apply plugin: 'glm.debug-lifecycle'
    apply plugin: 'glm.release-lifecycle'
    apply plugin: 'default-import'
    apply plugin: 'dev.nokee.visual-studio-ide'
    apply plugin: 'glm.isolated-file-tree'

    // Make sure that we know where to find unzipsfx.exe
    project.pluginManager.withPlugin('glm.installer-base') {
        installers.all {
            packages.withType(PkgZipInstallerPackage).all {
                // TODO: This doesn't seem to work properly, I get this error message:
                // * What went wrong:
                // Could not determine the dependencies of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller'.
                // > Failed to query the value of task ':zsfx_inst:zsfx_one:createPkgZipDebugInstaller' property 'ZSFX'.
                //    > Failed to query the value of property 'ZSFX'.
                //       > Cannot obtain value from provider of environment variable 'UNZIPSFX_LOCATION' at configuration time.
                //         Use a provider returned by 'forUseAtConfigurationTime()' instead.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').map { new File(it) }
                //     .orElse(provider {
                //             throw new GradleException(
                //                 "Please download unzipsfx from <https://sourceforge.net/projects/infozip/files/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip/download>, unzip it, and set the environment variable 'UNZIPSFX_LOCATION'"
                //             ) } )

                // I changed the line to the one below, but then it always throws the exception saying that the env var needs to be set.
                // ZSFX = providers.environmentVariable('UNZIPSFX_LOCATION').forUseAtConfigurationTime().map { new File(it) }
                ZSFX.fileProvider providers.environmentVariable('UNZIPSFX_LOCATION').forUseAtConfigurationTime().map { new File(it) }.orElse(provider {
                    throw new GradleException(
                            "Please download unzipsfx with the command 'curl -o unzip.zip <https://managedway.dl.sourceforge.net/project/infozip/UnZip%206.x%20%28latest%29/UnZip%206.0/unzip60.zip>', unzip it into a directory, and set the environment variable 'UNZIPSFX_LOCATION' to that location."
                    )
                })
            }
        }
    }
    // KHickel 02-10-2021 Change the build directory for each project to be underneath
    // rootProject.directory/build.
    // "ofs" means "Out oF Source" (e.g. not in the source tree).
    // The prj.name is the subproject name, which makes it easier to find something like
    // an outputs.txt/options.txt for a subproject when you want to.
    // And the md5 sum is added to make sure that the directories are unique to a subproject.
    // This avoids a problem when Gradle decides to include all the source directories in the include path.
    // If the build directory is below the source directory, then you start to get spurious rebuilds of
    // projects, this change avoids that.
    layout.buildDirectory.set(rootProject.file("build/ofs" + it.path.replaceAll(/:/, '-') + "-" + it.path.md5()))
}

project(':zsfx_inst') {
    subprojects {
        ext.versionTextInputFilename = 'VERSION.txt.in'
        ext.releaseString = '1.1.00'
    }
}

installationManifests {
    base {
        from('LICENSE')
        from('README.md')
        from('VERSION.txt.in')
    }
}

////////////////////////////////////////////////////////////////
// Utility function to take a string, add the .lib on the end for windows, .a for linux, and return the string.
def lib(String fname) {
    if(isWindows) {
        return fname + '.lib'
    } else {
        return fname + '.a'
    }
}

////////////////////////////////////////////////////////////////
// Find the files needed to build with Open SSL, I couldn't figure out how to do
// this with just providers without running into the 'no matching signature' error.
def OpenSslRootPath = System.getenv('GLM_OPENSSL_ROOT')
if(!OpenSslRootPath) {
    if(!isWindows) {
        println "The environment variable GLM_OPENSSL_ROOT is not defined, attempting to use system files from /usr."
        OpenSslRootPath = '/usr'
    }
}
if(!OpenSslRootPath) {
    throw new GradleException('The environment variable GLM_OPENSSL_ROOT is not define, please set it and try again.')
}
def libOpenSSLIncludePath = new File(OpenSslRootPath, 'include')
def libOpenSSLLibPathRelease = new File(OpenSslRootPath, 'lib')
def libOpenSSLLibPathDebug = new File(OpenSslRootPath, 'debug/lib')
def libOpenSSLLibNameDebug = lib('libssl')
def libOpenSSLLibNameRelease = lib('libssl')
def libCryptoLibNameDebug = lib('libcrypto')
def libCryptoLibNameRelease = lib('libcrypto')
if(!libOpenSSLLibPathDebug.exists()) {
    // Use the non-debug version
    libOpenSSLLibPathDebug = libOpenSSLLibPathRelease
}

def libOpenSSLLibCryptoReleaseFile = new File(libOpenSSLLibPathRelease, libCryptoLibNameRelease)
if(!isWindows) {
    if(!libOpenSSLLibCryptoReleaseFile.exists()) {
        // Try the linux x64 specific location
        libOpenSSLLibCryptoReleaseFile = new File(new File(libOpenSSLLibPathRelease, '/x86_64-linux-gnu/'), libCryptoLibNameRelease)
    }
}
if(!libOpenSSLLibCryptoReleaseFile.exists()) {
    throw new GradleException("The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, " +
                              "the file ${libOpenSSLLibCryptoReleaseFile} does not exist." )
}

def libOpenSSLLibCryptoDebugFile = new File(libOpenSSLLibPathDebug, libCryptoLibNameDebug)
if(!isWindows) {
    if(!libOpenSSLLibCryptoDebugFile.exists()) {
        // Try the linux x64 specific location
        libOpenSSLLibCryptoDebugFile = new File(new File(libOpenSSLLibPathRelease, '/x86_64-linux-gnu/'), libCryptoLibNameDebug)
    }
}
if(!libOpenSSLLibCryptoDebugFile.exists()) {
    throw new GradleException("The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, " +
                              "the file ${libOpenSSLLibCryptoDebugFile} does not exist." )
}



def libOpenSSLReleaseFile = new File(libOpenSSLLibPathRelease, libOpenSSLLibNameRelease)
if(!isWindows) {
    if(!libOpenSSLReleaseFile.exists()) {
        // Try the linux x64 specific location
        libOpenSSLReleaseFile = new File(new File(libOpenSSLLibPathRelease, '/x86_64-linux-gnu/'), libOpenSSLLibNameRelease)
    }
}
if(!libOpenSSLReleaseFile.exists()) {
    throw new GradleException("The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, " +
                              "the file ${libOpenSSLReleaseFile} does not exist." )
}

def libOpenSSLDebugFile = new File(libOpenSSLLibPathDebug, libOpenSSLLibNameDebug)
if(!isWindows) {
    if(!libOpenSSLDebugFile.exists()) {
        // Try the linux x64 specific location
        libOpenSSLDebugFile = new File(new File(libOpenSSLLibPathRelease, '/x86_64-linux-gnu/'), libOpenSSLLibNameDebug)
    }
}
if(!libOpenSSLDebugFile.exists()) {
    throw new GradleException("The environment variable GLM_OPENSSL_ROOT does not seem to specify a valid location, " +
                              "the file ${libOpenSSLDebugFile} does not exist." )

}


prebuiltLibraryManagement {
    libraries {
        'libcrypto' {
            groupId = 'system.Crypto'
            artifactId = 'libcrypto'
            version = 'current'
            variants {
                x86DebugStatic(StaticLibraryVariant) {
                    // includeRoot = openSslRootDir.dir('include').map(assertDirectoryExists())
                    // libraryFile = openSslRootDir.file('debug/lib/libcrypto.lib').map(assertFileExists())
                    includeRoot = libOpenSSLIncludePath;
                    libraryFile = libOpenSSLLibCryptoDebugFile;

                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'static')
                    attributes.put(Attribute.of('dev.nokee.buildType', String), 'debug')
                }
                x86ReleaseStatic(StaticLibraryVariant) {
                    // includeRoot = openSslRootDir.dir('include').map(assertDirectoryExists())
                    // libraryFile = openSslRootDir.file('lib/libcrypto.lib').map(assertFileExists())
                    includeRoot = libOpenSSLIncludePath;
                    libraryFile = libOpenSSLLibCryptoReleaseFile;

                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'static')
                    attributes.put(Attribute.of('dev.nokee.buildType', String), 'release')
                }
            }
        }
        'libssl' {
            groupId = 'system.OpenSSL'
            artifactId = 'libssl'
            version = 'current'
            variants {
                 x86DebugStatic(StaticLibraryVariant) {
                    // includeRoot = openSslRootDir.dir('include').map(assertDirectoryExists())
                    // libraryFile = openSslRootDir.file('debug/lib/libssl.lib').map(assertFileExists())
                    includeRoot = libOpenSSLIncludePath
                    libraryFile = libOpenSSLDebugFile

                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'static')
                    attributes.put(Attribute.of('dev.nokee.buildType', String), 'debug')
                }
                 x86ReleaseStatic(StaticLibraryVariant) {
                    // includeRoot = openSslRootDir.dir('include').map(assertDirectoryExists())
                    // libraryFile = openSslRootDir.file('lib/libssl.lib').map(assertFileExists())
                    includeRoot = libOpenSSLIncludePath
                    libraryFile = libOpenSSLReleaseFile

                    attributes.put(Attribute.of('dev.nokee.linkage', String), 'static')
                    attributes.put(Attribute.of('dev.nokee.buildType', String), 'release')
                }
            }
        }
    }
}

allprojects {
    pluginManager.withPlugin('glm.code-signing') {
        codeSigning.signtool.fileValue(org.gradle.internal.os.OperatingSystem.current().findInPath('signtool.exe'))
        codeSigning.signingCertificate = rootProject.file('MySPC.pfx')
        codeSigning.signingCertificatePassword = 'passwordx'
    }
    pluginManager.withPlugin('glm.publishing') {
        publishing.repositories.flatDir name: 'installers', dirs: "$rootDir/build/installers"
        repositories {
            mavenCentral() // because commons-codec for hashing
        }
    }
}
