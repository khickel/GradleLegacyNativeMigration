import static ConfigurationUtils.*

plugins {
    id 'dev.nokee.native-application'
    id 'dev.nokee.cpp-language'
    id 'dev.nokee.c-language'
    id 'glm.code-signing'

    id 'glm.windows-subsystem'
    id 'glm.installation-manifest-base'
}

import dev.nokee.language.c.CHeaderSet
import dev.nokee.language.cpp.CppHeaderSet

ext {
    windowsSubsystem = 'console'
}

// Set the project standard C++ compiler/linker options
application(Configure.withDefaultApplicationConfiguration())
application { app->

    // Set the executable filename
    baseName = 'util_1'
    
    // Add *.cpp/*.c to the project
    sources {
        cpp { from(fileTree(dir: '.', include: '*.cpp')) }
        c { from(fileTree(dir: '.', include: '*.c')) }
        configureEach(CppHeaderSet) { from(isolatedFileTree(dir: projectDir, include: '*.h')) }
        configureEach(CHeaderSet) { from(isolatedFileTree(dir: projectDir, include: '*.h')) }
    }

    // Example of adding a project specific linker command line option.
    // This should cause the following output in build\tmp\linkDebug\output.txt:
    //   Pass 1: Interval #1, time = 0.094s
    //     Wait PDB close: Total time = 0.000s
    //     Wait type merge: Total time = 0.000s
    //   Pass 2: Interval #2, time = 0.125s
    //   Final: Total time = 0.219s
    addVSLinkerOption("/TIME")(app)

    dependencies {
        implementation project(':static_lib')
    }
}

installationManifests {
    create('debug')
    create('release')
}
installationManifests.all {
    def buildType = name
    from(application.variants
            .filter { it.buildVariant.hasAxisOf(application.buildTypes.named(buildType)) }
            .map { it.find { it.developmentBinary.get().buildable } }
            .flatMap(Binaries.selectDevelopmentBinaryFile())) {
        into('bin')
    }
}
