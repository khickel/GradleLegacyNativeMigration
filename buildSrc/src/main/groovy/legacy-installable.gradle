void configureAsConsumableDependencyBucket(Configuration self) {
    self.canBeConsumed = true
    self.canBeResolved = false
}

void configureRuntimeLibrariesAttributes(Configuration self, ObjectFactory objects, String buildType) {
    self.attributes {
        attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, 'legacy-installer-libraries'))
        attribute(Attribute.of('legacy-installer.buildType', String), buildType)
    }
}

void configureExecutablesAttributes(Configuration self, ObjectFactory objects, String buildType) {
    self.attributes {
        attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, 'legacy-installer-binaries'))
        attribute(Attribute.of('legacy-installer.buildType', String), buildType)
    }
}

Provider<RegularFile> mapToExecutableFile(def application, String buildType) {
    // TODO(nokeedev): Provide better query methods to fetch the files generated by the a variant/binary
    //    Or, provide a better way to create custom consumable configuration
    //    Or, a mix of both
    return application.variants
            .filter { it.buildVariant.hasAxisOf(application.buildTypes.named(buildType)) }
            .flatMap { it.first().developmentBinary }
            .flatMap { it.linkTask }
            .flatMap { it.getLinkedFile() }
}

void createLegacyInstallerConfigurations(Project project, String buildType) {
    project.configurations.create("${buildType}InstallerRuntimeLibrariesElements") {
        configureAsConsumableDependencyBucket(it)
        configureRuntimeLibrariesAttributes(it, project.objects, buildType)

        // You could extendsFrom respective implementation to transitively include all shared libraries.
        //    However, you would have to ensure that all project applies the legacy-installation plugin
        //    Or, resolve the configuration leniently to ignore errors
    }
    project.configurations.create("${buildType}InstallerExecutablesElements") {
        configureAsConsumableDependencyBucket(it)
        configureExecutablesAttributes(it, project.objects, buildType)
        outgoing.artifact(mapToExecutableFile(project.application, buildType))
    }
}

configurations.matching { it.name.endsWith('mplementation') }.all {
    if (it.name.toLowerCase().contains('debug')) {
        createLegacyInstallerConfigurations(project, 'debug')
    } else if (it.name.toLowerCase().contains('release')) {
        createLegacyInstallerConfigurations(project, 'release')
    }
}

// TODO(nokeedev): Expose APIs on the component dependencies to create maintainable variant aware configuration for additional outgoing dependencies
//   A more ideal and flexible code would be the following:
//application {
//    variants.configureEach {
//        dependencies.register('installerRuntimeLibrariesElements', ConsumableDependencyBucket) {
//            attributes {
//                attribute(Usage.USAGE_ATTRIBUTE, project.objects.named(Usage, 'legacy-installer-libraries'))
//                attribute(Attribute.of('legacy-installer.buildType', String), buildVariant.get(TargetBuildType).name)
//            }
//        }
//        dependencies.create('installerExecutablesElements', ConsumableDependencyBucket) {
//            attributes {
//                attribute(Usage.USAGE_ATTRIBUTE, project.objects.named(Usage, 'legacy-installer-executables'))
//                attribute(Attribute.of('legacy-installer.buildType', String), buildVariant.get(TargetBuildType).name)
//            }
//            outgoing.artifact(developmentBinary.flatMap { it.executableFile })
//        }
//    }
//}