////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
// Gradle tasks and methods for creating installers, including the staging of exeuctables in sigma-web, s-cgi and similar directories.
// To use this add this line to the root gradle file:
//    apply from: 'installUtils.gradle'

def getDebugState(Project prj) {
    // May be enchanced to enable debugging for certain project names.
    def rv = true//false
    return rv
}

// Will create (and return) a debug or release aggregate task (e.g. legacyInstaller) in a target project,
// with the suffix 'Debug' or 'Release'.
// Then it will walk up the project tree, creating the same aggregate task if needed, and setting dependencies.
// If the target task already exists, it will just be returned.
def getOrCreateAggregateTaskForSubproject(Project prj, String taskNamePrefix, String descr, Boolean wantDebug) {
    String methodName = 'gOCATFS'
    def taskName = taskNamePrefix + (wantDebug ? 'Debug' : 'Release')
    def groupName = wantDebug ? 'debugGroup' : 'releaseGroup'
    def fullDesc = descr + (wantDebug ? ' - Debug' : ' - Release')
    def stdAggTaskName = wantDebug ? 'debug' : 'release'

    def debugOn = getDebugState(prj)

    if(debugOn) {
        println "Debug(${methodName}): getOrCreateAggregateTaskForSubproject: prj=${prj.path}, descr=${descr}, wantDebug=${wantDebug}"
    }

    // Loop up the path from the passed in project, creating the aggregate task as we go, making it depend on the descendant's aggregate task.
    def tPrj = prj
    def childTask = null
    while(tPrj != null) {
        // Get the aggregate task at this level, create it if it doesn't exist.
        def newTask = tPrj.tasks.findByName(taskName)
        if(newTask == null) {
            newTask = tPrj.tasks.create(taskName)
            newTask.group = getRootProject().property(groupName)
            newTask.description = fullDesc
            if(debugOn) { println "Debug(${methodName}): Created aggregate project task ${newTask.name} for project ${tPrj.path}, group=" + newTask.group }
        }

        // Make the new task at this level depend on the child task (from the previous loop iteration), if there is one.
        if(childTask){
            if(debugOn) { println "Debug(${methodName}): Setting aggregate project task named ${tPrj.path}:${newTask.name} to depend on child prj task ${childTask.name} for original input project ${prj.path}"}
            newTask.dependsOn(childTask)
        }

        // Make the aggregate task at this level depend on the new task (from the previous loop iteration), if there is one.
        if(debugOn) { println "Debug(${methodName}): Setting standard aggregate project task named ${tPrj.path}:${stdAggTaskName} to depend on new agg task ${newTask.name} for original input project ${prj.path}"}
        tPrj.tasks.findByName(stdAggTaskName).dependsOn(newTask)

        // Set up for next loop iteration.
        tPrj = tPrj.parent
        childTask = newTask
    }

    def rv = prj.tasks.findByName(taskName)
    if(debugOn) {println "Debug(${methodName}): returning task ${prj.path}:${rv.name}."}
    return rv
}

////////////////////////////////////////////////////////////////
// Add an addProjOutputCopyFilesTask task to any subproject that has an "extra" property with a name matching the value of projMapPropName.
// The property is a map where the key is the file name that the CppApplication is producing,
// that is the output of a LinkExecutable task.
// and the value is a File, or List of Files specifying where the executable should be copied.
//
// This code is based on this snippet from "thadhouse" on the gradle native slack channel, 2020-07-13.
// def copyToTask = tasks.register("copyToOutputsInApp", Copy) {
//     into "$buildDir/outputs"
// }
// application.binaries.whenElementFinalized { binary ->
//     if (binary.name.endsWith('Debug')) {
//         copyToTask.configure {
//             it.dependsOn binary.linkTask
//             it.from binary.linkTask.get().linkedFile
//         }
//     }
// }
//
// TODO: This method is too big, I should at least take the code that is duplicated for debug/release and move
// it into a new method, then call it once for debug and one for release.
def addProjOutputCopyFilesTask(Project prj, Project parent, String taskPrefix, String projMapPropName, String basePath, String descr, Boolean wantTasksInParent) {
    String methodName = 'aPOCFT'
    def debugTasks = [:]
    def releaseTasks = [:]
    def tgtPrj = wantTasksInParent ? parent : prj

    def debugOn = getDebugState(prj)

    if(debugOn) {
        println "Debug(${methodName}): Called for project ${prj.path}, parent ${parent? parent.path : 'null parent'}, taskPrefix=${taskPrefix}, projMapPropName=${projMapPropName ?: 'null'}, wantTasksInParent=${wantTasksInParent}"
    }

    // Create an aggregate debug task in the project, parent and root, this task will reference all the individual debug copy tasks.
    if(debugOn) {
        println "Debug(${methodName}): addProjOutputCopyFilesTask calling getOrCreateAggregateTaskForSubproject for prj=${prj.path}, parent=${parent.path}}"
    }
    def dbgAggTask = getOrCreateAggregateTaskForSubproject(tgtPrj, taskPrefix, descr, true)
    def dbgCopyAllTask = tgtPrj.tasks.findByName(dbgAggTask.name + '_CopyAll')
    if(dbgCopyAllTask == null) {
        dbgCopyAllTask = tgtPrj.tasks.create(dbgAggTask.name + '_CopyAll')
    }
    // This task might have been created from a project that wasn't able to set the
    // dependency, so we'll always set it, whether we created it or not.
    if(debugOn) { println "Debug(${methodName}): Setting dbgAggTask task ${dbgAggTask.path} to depend on new prj task ${dbgCopyAllTask.path}."}
    dbgAggTask.dependsOn(dbgCopyAllTask)

    // Create an aggregate release task in the project, parent and root, this task will reference all the individual release copy tasks.
    def relAggTask = getOrCreateAggregateTaskForSubproject(tgtPrj, taskPrefix, descr, false)
    def relCopyAllTask = tgtPrj.tasks.findByName(relAggTask.name + '_CopyAll')
    if(relCopyAllTask == null) {
        relCopyAllTask = tgtPrj.tasks.create(relAggTask.name + '_CopyAll')
    }
    relAggTask.dependsOn(relCopyAllTask)

    // The subproject contains a line like this mapping a directory key to a filename value:
    //         ext.projMapPropName = [ (file("c:/temp/target/dir")) : "foo" ]
    // The filename could be an array of filenames:
    //         ext.projMapPropName = [ (file("c:/temp/target/dir")) : ["bar", "foo" ]
    // Or it could be a map containing filenames and options:
    //         ext.projMapPropName = [ (file("c:/temp/target/dir")) : ["codeSign":true,"fileBasename":"foo" ]]
    // Or even an array of maps:
    //         ext.projMapPropName = [ (file("c:/temp/target/dir")) : [
    //                  ["codeSign":true,"fileBasename":"foo"],
    //                  ["codeSign":false,"fileBasename":"bar"]
    //         ]
    prj.property(projMapPropName).eachWithIndex { path, fileBasename, idx ->
        // Resolve the passed in (optional) basepath with the path from the map.
        // Handle the cases where the path from the map is a string and where it's a File.
        def File targetPath
        if(basePath == null) {
            if(path instanceof java.io.File) {
                targetPath = path
                if(debugOn) {
                    println "Debug(${methodName}): resolved basePath:null and file path:${path.path} to : ${targetPath.path} for project ${tgtPrj.path}"
                }
            } else {
                targetPath = file(path)
                if(debugOn) {
                    println "Debug(${methodName}): resolved basePath:null and file string:${path} to : ${targetPath.path} for project ${tgtPrj.path}"
                }
            }
        } else {
            if(path instanceof java.io.File) {
                targetPath = file(basePath + '/' + path.path)
                if(debugOn) {
                    println "Debug(${methodName}): resolved basePath:${basePath} and file path:${path.path} to : ${targetPath.path} for project ${tgtPrj.path}"
                }
            } else {
                targetPath = file(basePath + '/' + path)
                if(debugOn) {
                    println "Debug(${methodName}): resolved basePath:${basePath} and file string:${path} to : ${targetPath.path} for project ${tgtPrj.path}"
                }
            }
        }

        if(debugOn) {
            println "Debug(${methodName}): handling project ${prj.name}, ${projMapPropName} index ${idx}, target file name=${fileBasename}, target path=${targetPath.path} for project ${tgtPrj.path}"
        }

        ///// Handle the target filename(s), turn them into an array, even if there's only one.
        def fnameList = []
        if(fileBasename instanceof java.util.ArrayList) {
            // We have multiple values, so just set the array to the incoming array.
            fnameList = fileBasename
        } else {
            // We have a single file value, so push it into the array.
            fnameList.push(fileBasename)
        }
        fnameList.eachWithIndex { fname, idx2 ->
            ///// Check to see if what we think is the file name is actually a map, which may include some option settings.
            Boolean shouldSign = false
            Boolean addExeOrDllSuffix = true
            String outputFilename = null
            String src_path = prj.buildDir.path
            if(fname instanceof Map) {
                def targetMap = fname
                fname = null

                if(debugOn) {println "Debug(${methodName}): Handling map instead of file name for project ${tgtPrj.path}."}
                if(targetMap.containsKey('codeSign')) {
                    if(isWindows) {
                        shouldSign = targetMap['codeSign']
                    } else {
                        println "codeSign option ignored on Linux for ${tgtPrj.path}."
                    }
                    if(debugOn) {println "Debug(${methodName}): Debug: shouldSign=${shouldSign}"}
                } else {
                    if(debugOn) {println "Debug(${methodName}): Debug: shouldSign=false"}
                }
                if(targetMap.containsKey('fileBasename')) {
                    fname = targetMap['fileBasename']
                    if(debugOn) {println "Debug(${methodName}): fname=${fname} for project ${tgtPrj.path}"}
                }
                if(targetMap.containsKey('addExeOrDllSuffix')) {
                    addExeOrDllSuffix = targetMap['addExeOrDllSuffix']
                    if(debugOn) {println "Debug(${methodName}): addExeOrDllSuffix=${addExeOrDllSuffix} for project ${tgtPrj.path}"}
                }
                if(targetMap.containsKey('outputFilename')) {
                    outputFilename = targetMap['outputFilename']
                    if(debugOn) {println "Debug(${methodName}): outputFilename=${outputFilename} for project ${tgtPrj.path}"}
                }
                if(targetMap.containsKey('src_path')) {
                    src_path = targetMap['src_path']
                    if(debugOn) {println "Debug(${methodName}): src_path=${src_path} for project ${tgtPrj.path}"}
                }
            } else if (fname instanceof String) {
                if(debugOn) { println "Debug(${methodName}): fname=${fname} for project ${tgtPrj.path}"}
            }
            if(outputFilename == null) {
                outputFilename = fname
            }
            if(debugOn) {println "Debug(${methodName}): fname after resolution is ${fname}"}

            def targetFilename = fname
            def isWindows = org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.currentOperatingSystem.isWindows()
            if(addExeOrDllSuffix) {
                // Sanity check, the file names in ext.${projMapPropName} should not contain ".exe" or ".dll", as we will add that
                // below if we're running on windows.
                if(fname.endsWith('.exe')) {
                    throw new GradleException("Stopping build because the ext.${projMapPropName} setting for subproject ${prj.name} contains .exe as part of the filename.")
                }
                if(fname.endsWith('.dll')) {
                    throw new GradleException("Stopping build because the ext.${projMapPropName} setting for subproject ${prj.name} contains .dll as part of the filename.")
                }

                if(prj.hasProperty('library')) {
                    if(isWindows){
                        targetFilename += ".dll"
                        outputFilename += ".dll"
                    } else {
                        targetFilename += ".so"
                        outputFilename += ".so"
                    }
                } else {
                    if(isWindows) {
                        targetFilename += ".exe"
                        outputFilename += ".exe"
                    }
                }
            }

            //////////////// Debug Tasks
            // Use the dynamic API for task inputs and outputs to configure a copy task that we won't execute, but it is
            // used later as an input the the copy method, alowing us to execute a single task that does the copy and the
            // signtool step.
            // See https://docs.gradle.org/current/userguide/working_with_files.html#sec:copying_multiple_files_example
            // search for Example 41. Copying files using the copy() method with up-to-date check
            def dbgTaskName = "${taskPrefix}DebugCopy_${prj.name}_${idx}_${idx2}"
            if(debugOn) {println "Debug(${methodName}): about to register debug copy task name ${tgtPrj.path}:${dbgTaskName} for file name ${fname}"}

            // This task will be invoked via the copy method from the next task we define.
            def newDebugCopyTask = tgtPrj.tasks.register(dbgTaskName + '_CopyOnly', Copy) {
                rename { return outputFilename } // Name the file as specified, may not actually be a different name, but this works either way.

                // This causes the exec task to have the Source directory as an input, which isn't good.
                //into targetPath.path

                // I don't think this is needed.
                //outputs.file(targetPath.path + "/" + targetFilename)
                setDescription("Copy file ${src_path}/${targetFilename} to path ${targetPath.path}.")
                doLast {
                    if(debugOn) {
                        println "Debug(${methodName}): ${it.name} in copyTask, copying debug file named ${targetFilename} to ${targetPath.path}"
                        dumpTaskToJson(tgtPrj,it, file(tgtPrj.projectDir), "${it.name}_from_copyTask.json")
                    }
                }
            }
            def newDebugTask = tgtPrj.tasks.register(dbgTaskName) {
                if(addExeOrDllSuffix) {
                    if(debugOn) {
                        println "Debug(${methodName}): Registering debug task named ${tgtPrj.path}:${name} for file named ${targetFilename}, with inputs from ${newDebugCopyTask}, inputs=${inputs.files(newDebugCopyTask)}"
                        String ifiles = ""
                        it.inputs.files.each { f ->
                            ifiles += ",${f.path} "
                        }
                        println "Debug(${methodName}): ExecTask ${tgtPrj.path}:${name} inputs before adding inputs from copyTask: ${ifiles}"
                        dumpTaskToJson(tgtPrj,it, file(tgtPrj.projectDir), "${it.name}_from_generic_task_1.json")
                    }
                    inputs.files(newDebugCopyTask)
                            .withPropertyName("inputs")
                            .withPathSensitivity(PathSensitivity.RELATIVE)
                } else {
                    // For use with a .cnf file or something like that.  We don't want to depend on the link task,
                    // we want to depend on the file itself.
                    if(debugOn) {
                        println "Debug(${methodName}): Registering debug task named ${tgtPrj.path}:${name} for file named ${targetFilename}, with input file from project ${prj.path}:${prj.name}: ${src_path}/${targetFilename}"
                    }
                    inputs.file("${src_path}/${targetFilename}")
                }
                outputs.file(targetPath.path + "/" + outputFilename)

                doLast {
                    if(debugOn) {
                        println "Debug(${methodName}): ${it.name} in debug copy/sign task, copying file ${targetFilename} " +
                                "to ${targetPath.path}/${outputFilename} using task ${newDebugCopyTask.name}."
                        dumpTaskToJson(tgtPrj,it, file(tgtPrj.projectDir), "${it.name}_from_generic_task_3.json")
                    }
                    copy {
                        from inputs.files
                        rename { return outputFilename } // Name the file as specified, may not actually be a different name, but this works either way.
                        into targetPath.path
                    }
                    if(shouldSign) {
                        if(debugOn) {println "Debug(${methodName}): ${it.name} in newDebugTask register call, should sign is on for file ${targetFilename} to ${targetPath.path}."}
                        exec { commandLine 'signtool', 'sign', '/fd', 'SHA256', '/a', '/v', '/f', getRootProject().property('codeSignCert'),
                                '/p', getRootProject().property('codeSignPassword'), "${targetPath.path}/${targetFilename}" }
                    }
                }
            }

            // Map of the copy/sign task to a map with the code sign setting, and the copy task, which will have the input set later based on the build variant.
            if(debugOn) {println "Debug: pushing debug task ${newDebugTask.name}, shouldSign=${shouldSign}, copy only task named ${newDebugCopyTask.name}, file ${targetFilename}, outputFilename ${outputFilename}, targetPath ${targetPath.path} for project=${tgtPrj.path}"}
            debugTasks[newDebugTask] = [
                    'codeSign':shouldSign,
                    'copyTask':newDebugCopyTask,
                    'addExeOrDllSuffix':addExeOrDllSuffix
            ]


            //////////////// Release Tasks

            def relTaskName = "${taskPrefix}ReleaseCopy_${prj.name}_${idx}_${idx2}"
            if(debugOn) {println "Debug(${methodName}): about to register release copy task name ${tgtPrj.path}:${relTaskName} for file name ${fname}"}
            def newReleaseCopyTask = tgtPrj.tasks.register(relTaskName + '_CopyOnly', Copy) {
                rename { return outputFilename } // Name the file as specified, may not actually be a different name, but this works either way.

                // This causes the exec task to have the Source directory as an input, which isn't good.
                //into targetPath.path

                // I don't think this is needed.
                //outputs.file(targetPath.path + "/" + targetFilename)
                doLast {
                    if(debugOn) {
                        println "Debug(${methodName}): ${it.name} in copyTask, copying release file named ${targetFilename} to ${targetPath.path}"
                        dumpTaskToJson(tgtPrj,it, file(tgtPrj.projectDir), "${it.name}_from_copyTask.json")
                    }
                }
            }
            def newReleaseTask = tgtPrj.tasks.register(relTaskName) {
                if(addExeOrDllSuffix) {
                    if(debugOn) {
                        println "Debug(${methodName}): Registering release task named ${tgtPrj.path}:${name} for file named ${targetFilename}, with inputs from ${newReleaseCopyTask}, inputs=${inputs.files(newReleaseCopyTask)}"
                    }
                    inputs.files(newReleaseCopyTask)
                            .withPropertyName("inputs")
                            .withPathSensitivity(PathSensitivity.RELATIVE)
                } else {
                    // For use with a .cnf file or something like that.  We don't want to depend on the link task,
                    // we want to depend on the file itself.
                    if(debugOn) {
                        println "Debug(${methodName}): Registering release task named ${tgtPrj.path}:${name} for file named ${targetFilename}, with input file from project ${prj.path}:${prj.name}: ${src_path}/${targetFilename}"
                    }
                    inputs.file("${src_path}/${targetFilename}")
                }
                outputs.file(targetPath.path + "/" + outputFilename)

                doLast {
                    if(debugOn) {
                        println "Debug(${methodName}): ${it.name} in release copy/sign task, copying file ${targetFilename} to ${targetPath.path} using task ${newReleaseCopyTask.name}"
                        dumpTaskToJson(tgtPrj,it, file(tgtPrj.projectDir), "${it.name}_from_generic_task_1.json")
                    }
                    copy {
                        from inputs.files
                        rename { return outputFilename } // Name the file as specified, may not actually be a different name, but this works either way.
                        into targetPath.path
                    }
                    if(shouldSign) {
                        if(debugOn) {println "Debug(${methodName}): ${it.name} in newReleaseTask register call, should sign is on for file ${targetFilename} to ${targetPath.path}."}
                        exec { commandLine 'signtool', 'sign', '/fd', 'SHA256', '/a', '/v', '/f', getRootProject().property('codeSignCert'),
                                '/p', getRootProject().property('codeSignPassword'), "${targetPath.path}/${targetFilename}" }
                    }
                }
            }
            // Map of the copy/sign task to a map with the code sign setting, and the copy task, which will have the input set later based on the build variant.
            if(debugOn) {println "Debug: pushing release task ${newReleaseTask.name}, shouldSign=${shouldSign}, copy only task named ${newReleaseCopyTask.name}, file ${targetFilename}, outputFilename ${outputFilename}, targetPath ${targetPath.path} for project=${tgtPrj.path}"}
            releaseTasks[newReleaseTask] = [
                    'codeSign':shouldSign,
                    'copyTask':newReleaseCopyTask,
                    'addExeOrDllSuffix':addExeOrDllSuffix
            ]
        }
    }

    // When each referenced task has been finalized, set the dependencies for the copy tasks that we created, we can't do it before that time.
    prj.components.main.binaries.whenElementFinalized { binary ->
        if (binary.name.endsWith('Debug')) {
            if(debugOn) {println "Debug(${methodName}): about to configure ${debugTasks.size()} debug tasks."}
            debugTasks.each { et, optionMap ->
                def copyTask = optionMap['copyTask']
                if(debugOn) { println "Debug: configuring debug task ${et.name}, copytask=${copyTask.name}" }
                if(optionMap['addExeOrDllSuffix']) {
                    copyTask.configure {
                        if(debugOn) {
                            println "Debug(${methodName}): Updating debug copy task ${prj.path}:${et.name} for binary ${binary.name}, adding dependency on linker task named ${binary.linkTask.get().name}, setting from file " +
                                    binary.linkTask.get().linkedFile.getAsFile().get().path
                            String ifiles = ""
                            it.inputs.files.each { f ->
                                ifiles += ",${f.path} "
                            }
                            println "Debug(${methodName}): CopyTask inputs before adding linked file: ${ifiles}"
                        }
                        inputs.file(binary.linkTask.get().linkedFile)
                        it.dependsOn binary.linkTask
                    }
                    et.configure {
                        if(debugOn) {
                            println "Debug(${methodName}): Updating debug exec task ${tgtPrj.path}:${et.name} for binary ${binary.name}, adding dependency on linker task named ${binary.linkTask.get().name}, inputs=${binary.linkTask.get().linkedFile}, file=" + binary.linkTask.get().linkedFile.getAsFile().get().name
                        }
                        it.dependsOn binary.linkTask
                        inputs.file(binary.linkTask.get().linkedFile)
                    }
                }

                if(debugOn) {
                    println "Debug(${methodName}): Updating debug task ${tgtPrj.path}:${dbgCopyAllTask.name} which now also dependsOn ${et.name}"
                }
                dbgCopyAllTask.dependsOn(et)
                tgtPrj.tasks.findByName('debug').dependsOn(dbgAggTask)
            }
        }
        if (binary.name.endsWith('Release')) {
            if(debugOn) {println "Debug: about to configure ${releaseTasks.size()} debug tasks."}
            releaseTasks.each { et, optionMap ->
                def copyTask = optionMap['copyTask']
                if(debugOn) {println "Debug: configuring release task ${et.name}, copytask=${copyTask.name}"}
                if(optionMap['addExeOrDllSuffix']) {
                    copyTask.configure {
                        if(debugOn) {
                            println "Debug(${methodName}): Updating release copy task ${prj.path}:${et.name} for binary ${binary.name}, adding dependency on linker task named ${binary.linkTask.get().name}, setting from file " +
                                    binary.linkTask.get().linkedFile.getAsFile().get().name
                        }
                        inputs.file(binary.linkTask.get().linkedFile)
                        it.dependsOn binary.linkTask
                    }
                    et.configure {
                        if(debugOn) {
                            println "Debug(${methodName}): Updating release exec task ${tgtPrj.path}:${et.name} for binary ${binary.name}, adding dependency on linker task named ${binary.linkTask.get().name}, inputs=${binary.linkTask.get().linkedFile}."
                            binary.linkTask.get().linkedFile.getAsFile().get().name
                        }

                        it.dependsOn binary.linkTask
                        inputs.file(binary.linkTask.get().linkedFile)
                    }
                }

                if(debugOn) {
                    println "Debug(${methodName}): Updating release task ${tgtPrj.path}:${relCopyAllTask.name} which now also dependsOn ${et.name}"
                }
                relCopyAllTask.dependsOn(et)
                tgtPrj.tasks.findByName('release').dependsOn(relAggTask)
            }
        }
    }
}

////////////////////////////////////////////////////////////////
// Creates a self extracting old style zip installer, returns maps with the created tasks.
def createZipInstallerTasks(Project prj,
                            String installerFileName, String installerFilePath,
                            String productName, String productDescription,
                            String programDescription, String defaultPath,
                            String serviceName, String runProgram,
                            Task toDependOn, String inputPath, String inputIncludeSpec,
                            Boolean silentInstaller
) {

    def rv = [:]
    def instTaskNameSuffix = 'Installer'
    if(silentInstaller) {
        instTaskNameSuffix = 'SilentInstaller'
    }
    def createParmsHeader = prj.tasks.register("createParmsHFor${instTaskNameSuffix}") {
        outputs.file "${prj.projectDir}/parms.h"
        file("${prj.projectDir}/parms.h").text = """
#define PROGRAM_DESCR    \"${programDescription}\"
#define DEFAULT_PATH     \"${defaultPath}\"
#define SERVICE_NAME     \"${serviceName}\"
#define RUN_PROGRAM      \"${runProgram}\"
"""
    }

    // TODO: Can I move the application in here too? probably not but would be nice, which means I need to pass in the path, or just assume it's here.

    def ZNST = file("${prj.buildDir}/${installerFileName}").path
    def BDRY = file("${TopProjDir}/zsfx_inst/zsfx_base/boundary.txt").path
    def ZSFX = file("${TopProjDir}/zsfx_inst/zsfx_base/unzipsfx.exe").path
    def CSETUP = file("${buildDir}/install/wintools/CSetup.exe").path
    def ZPKG = file("${prj.buildDir}/pkg.zip").path


    // TODO: should I move the zip in here too? have to get the dependencies right.
    // For the moment I'm not doing it because (using command_center.gradle as an example),
    // the CCI_stage task then wouldn't have anything to use as an output, so gradle
    // would always run the task, which isn't desireable.

    // Task to create the installer itself - debug
    def debugInstallerTask = prj.tasks.register("createDebug${instTaskNameSuffix}") {
        dependsOn(createParmsHeader)
        dependsOn(toDependOn)

        // The installer tasks need to also depend upon the installer stage/copy task, at least with the way things are set up now.
        // TODO Someday, really this should depend on the link task and we should know to use the debug exe,
        // but the calling project is currently telling us to take the .exe from the top of the Build directory.
        // So this is a bit of a hack, but I'm hoping to do much better when we can move to Nokee.
        dependsOn(prj.tasks.findByName('stageDebug_CopyAll'))

        inputs.files(
                ZNST,
                BDRY,
                ZSFX,
                fileTree(dir:inputPath, include: inputIncludeSpec)
        )
        outputs.files(installerFilePath)
        doLast {
            def instFile = file(installerFilePath)
            def instFileDir = instFile.getAbsoluteFile().getParent()
            if(!file(ZNST).exists()) {
                throw new GradleException("Unable to find ZNST file ${ZNST}.");
            }
            if(!file(BDRY).exists()) {
                throw new GradleException("Unable to find BDRY file ${BDRY}.");
            }
            if(!file(ZSFX).exists()) {
                throw new GradleException("Unable to find ZFSX file ${ZSFX}.");
            }
            if(!file(ZPKG).exists()) {
                throw new GradleException("Unable to find ZPKG file ${ZPKG}.");
            }
            exec {
                workingDir "${inputPath}"
                if(silentInstaller) {
                    commandLine "cmd", "/C", "copy", "/b", "${ZNST}+${BDRY}+${ZSFX}+${ZPKG}", instFile.getPath()
                } else {
                    logger.info("Executing command: cmd /C copy /b ${ZNST}+${BDRY}+${ZSFX}+${ZPKG}, ${instFile.getPath()}")
                    commandLine "cmd", "/C", "copy", "/b", "${ZNST}+${BDRY}+${ZSFX}+${ZPKG}", instFile.getPath()
                }
            }
            exec {
                workingDir instFile.getParentFile()
                commandLine 'signtool', 'sign', '/fd', 'SHA256', '/a', '/v', '/f', getRootProject().property('codeSignCert'),
                        '/p', getRootProject().property('codeSignPassword'), instFile.name
            }
        }
    }
    tasks.findByName('debug').dependsOn(debugInstallerTask)
    rv['debugInstallerTask'] = debugInstallerTask

    // Task to create the installer itself - release
    def releaseInstallerTask = prj.tasks.create("createRelease${instTaskNameSuffix}") {
        dependsOn(createParmsHeader)
        dependsOn(toDependOn)
        def relCopy = prj.tasks.findByName('stageRelease_CopyAll')
        if(relCopy) {
            dependsOn(relCopy)
        }
        inputs.files(
                ZNST,
                BDRY,
                ZSFX,
                fileTree(dir:inputPath, include: inputIncludeSpec)
        )
        outputs.files(installerFilePath)
        doLast {
            def instFile = file(installerFilePath)
            def instFileDir = instFile.getAbsoluteFile().getParent()
            exec {
                workingDir "${inputPath}"
                commandLine "cmd", "/C", "copy", "/b", "${ZNST}+${BDRY}+${ZSFX}+${ZPKG}", instFile.getPath()
            }
            exec {
                workingDir instFile.getParentFile()
                commandLine 'signtool', 'sign', '/fd', 'SHA256', '/a', '/v', '/f', getRootProject().property('codeSignCert'),
                        '/p', getRootProject().property('codeSignPassword'), instFile.name
            }
        }
    }
    tasks.findByName('release').dependsOn(releaseInstallerTask)
    rv['releaseInstallerTask'] = releaseInstallerTask

    return rv
}

// We need to "convert" our groovy method(s) to Closures, otherwise they won't be visible in
// other Gradle files.
// We wouldn't have to do this if these methods were in the root Gradle file, but this way
// we can refactor things to keep the root Gradle file cleaner.
// See https://stackoverflow.com/questions/18715137/extract-common-methods-from-gradle-build-script
ext {
    getOrCreateAggregateTaskForSubproject = this.&getOrCreateAggregateTaskForSubproject
    addProjOutputCopyFilesTask = this.&addProjOutputCopyFilesTask
    createZipInstallerTasks = this.&createZipInstallerTasks
}
